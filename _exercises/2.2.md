---
week: 2
lab: 2
lang: python
title: Functions and modules
description: In this set of exercises we will explore functions and build some structured code in our own module.
---

{% assign challenges = site.challenges | where:"lab", 2.2 | sort: "id" %}

In this set of exercises we will develop some structure in our code using [functions]({{"/references/functions" | relative_url}}) and build our own python module.

{% include toc.md %}

## Functions

We often need to do the same things multiple times with different data.
We create functions as reusable bits of code.
We can think of functions as saved recipes.

We define a function using a [compound statement]({{"references/compound-statements" | relative_url }}) with the `def` keyword.
This is followed by a suitable function name. 
We specify what values the function can receive as *arguments* within the parentheses.
The function body can contain any number of valid python statements.

```python
def my_function(arg1, arg2, kwarg3=None):
    return "ignoring all arguments"
```
The above function takes two *positional* arguments (`arg1` and `arg2`) and one *keyword* argument (`kwarg3` with a default value of `None`).
It then ignores these arguments and simply returns a string.

Whenever we call the function, it will return the same string every time, no matter what arguments are provided.

```python
a = my_function(1, 2, kwarg3="hello")
print(a)
```

This is not a very useful function.

```plaintext
ignoring all arguments
```



{{ challenges[0] }}

## A function to generate HTML fragments

We are going to spend some time developing a function.
Imagine we are writing a programme to convert [markdown](https://en.wikipedia.org/wiki/Markdown) files into HTML.
We need a function for part of the rendering code, to generate HTML fragments as strings.

The following example function implements a simple [f-string]({{"references/f-strings" | relative_url }}) which adds HTML tags around some provided arguments.

```python
def html_element(content, tag):
    return f"<{tag}>{content}</{tag}>"
```

The function containing a `return` statement.
It will return a formatted string containing the `content` argument wrapped in opening and closing HTML tags with the given `tag` name.

### Arguments

When we call our function, we pass *arguments* within parentheses.
For example, if we want a level 1 heading element (`<h1></h1>`) containing the text `'hello world'` then we can use our function like this:

```python
heading = html_element('hello world', 'h1') 
```

Within the function, the arguments are passed into the f-string and returned.
The function call evaluates to the returned value which is then assigned to the `heading` variable.

```plaintext
<h1>hello world</h1>
```

We can use the function again, with different arguments.

```python
subheading = html_element('reusable functions', 'p')
```

In this case we are passing the string `'reusable function'` as the `content` argument and `'p'` as the `tag` argument.
The function *returns* the formatted string which is assigned to the `subheading` variable.

```plaintext
<p>reusable functions</p>
```

This simple function could prove very useful.
It will avoid the need to write lots of similar code and can be tested thoroughly to reduce the potential for mistakes.

## Defining a *library* module

Our function works so well that we find we have multiple scripts that need to use it.
Rather than copying and pasting our function from one script to another (creating a maintenance nightmare), we can place it into a *module* and import it into our scripts.

Move the function into a new file called **my_library.py** in the same folder as your working file.

That's it, we've created our first python module.

> A module is just a file with a *.py* extension.
> We can choose any filename we like, (though we should follow the [PEP8](https://peps.python.org/pep-0008/#package-and-module-names) style guide) and we need to be careful to avoid clashes with existing modules from the standard library.


### Importing a module

Now, back in our working file we can import the `my_library` module and access the `html_element` function using dot notation.

```python
import my_library

print(my_library.html_element("emphasis", "em"))
print(my_library.html_element("bold", "strong"))
print(my_library.html_element("heading", "h2"))
```

This generates the HTML output we want.

```html
<em>emphasis</em>
<strong>bold</strong>
<h2>heading</h2>
```

> Notice that modules are objects.
> We can pass them to `type()` just like any other value.
> ```python
> import my_library
>
> print(type(my_library))
> ```
> ```plaintext
> <class 'module'>
>```

However, this additional module reference and dot notation makes our code a bit awkward.

### Importing a function `from` our module

In a simple case like this, we can use the `from` keyword to directly import our `html_element` function rather than importing the entire `my_library` module.


```python
from my_library import html_element

print(html_element("emphasis", "em"))
print(html_element("bold", "strong"))
print(html_element("heading", "h2"))
```

We can now easily share the functionality between modules whilst only needing to maintain one copy of the code.

> Sometimes it can be useful to keep the module name in the code so its clear where everything comes from.
This is especially true if we are importing stuff from many different modules.

## Upgrading our function

When creating a new programme it is rare for code to remain stable for long.
It is a natural aspect of software development that, as we encounter and solve problems, our code will become more complex (and hopefully more useful) over time.

> If you are presented with a large problem to solve, break it down into smaller pieces and solve the easiest part first.
> A productive way to work is to discover and implement the problem in stages, beginning with a simple proof-of-concept and adding elements of functionality incrementally.
> For more examples of this, see [refactoring]({{"references/refactoring" | relative_url }}).

Our `html_element` function works well for the simple cases we have looked at so far.
However, it doesn't allow us to create HTML elements with attributes.

Perhaps we want to generate an HTML fragment like this:

```html
<a href="#html-attributes">HTML attributes</a> 
```

This is a hyperlink or an anchor element (`<a>`).
The `href` attribute is pointing to another element within the page that has the specified `id` attribute.
The other element might look like this:

```html
<h2 id="html-attributes">HTML attributes</h2>
```

HTML attributes are specified as space-separated `attribute="value"` pairs within the opening tag of an element, after the tag name.
We need to upgrade our `html_element` function to accept attribute names and values.
Attributes are essentially `{key: value}` pairs and so they map nicely onto keyword arguments.

Let's say we wanted to add an `href` argument.
We could do something like this:

```python
def html_element(content, tag, href=None):
    attrs = ""
    if href:
        attrs = f' href="{href}"'
    return f"<{tag}{attrs}>{content}</{tag}>"
```

This allows for creating an `<a href="something">link</a>` like this.

```python
html_element("link", "a", href="something")
```

However, if we want our function to be general purpose then we would need to dd keyword argument options for every possible HTML attribute.
This solution works as a proof-of-concept for the formatting, but it doesn't scale up or generalise in the way we want.

We can use the ability to take [arbitrary keyword arguments]({{"references/functions#argument-unpacking" | relative_url}}) to provide our function with a much more general purpose interface.

```python
def html_element(content, tag, **attributes):
    print(attributes)
    return f"<{tag}>{content}</{tag}>"
```

The double asterisk on the `**attributes` argument merges any keyword arguments into a single dictionary.
So the calling code can add as many arbitrary arguments as it needs and these will be merged into a dictionary of requested attributes.

> The current implementation simply prints the dictionary as a proof-of-concept.

Now we can add keyword arguments like this:

```python
html_element("link", "a", href="something")
```

This generates output without attributes, but it prints the dictionary of keyword arguments.

```plaintext
{'href': 'something'}
```

If we add an `id` attribute too, we can.

```python
html_element("link", "a", href="something", id="hi")
```
```plaintext
{'href': 'something', 'id': 'hi'}
```


We need to convert this into the appropriate format and insert into our result.
We can start by using a [list comprehension]({{"references/list-comprehensions" | relative_url }}) to convert the `attributes` dictionary into a list of HTML-formatted attributes.

```python
def html_element(content, tag, **attributes):
    attrs = [f'{k}="{v}"' for k, v in attributes.items()]
    print(attrs)
    return f"<{tag}>{content}</{tag}>"
```

Notice we are looping over the [`dict.items()`](https://docs.python.org/3/tutorial/datastructures.html#looping-techniques) iterable.

> calling `dict.items()` on any dictionary returns an iterable that yields the `{key: value}` pairs as tuples in the form `(key, value)`.
Our code unpacks these into the variables `k` and `v` within the list comprehension.

Again, the output is unchanged but we can see the dictionary has been transformed into a list of strings.

```python
html_element("link", "a", href="something", id="hi")
```
```plaintext
['href="something"', 'id="hi"']
```

This is close to what we need.
The next step is to convert the list into a space-separated string (using [`str.join()`](https://docs.python.org/3/tutorial/datastructures.html#looping-techniques)).
We can now add this new string into the formatted output.

```python
def html_element(content, tag, **attributes):
    attrs = [f'{k}="{v}"' for k, v in attributes.items()]
    attrs = " ".join(attrs)
    return f"<{tag}{attrs}>{content}</{tag}>"
```

However, there is a missing space between the attributes and the opening tag name.

```python
html_element("link", "a", href="something", id="hi")
```
```plaintext
<ahref="something" id="hi">HTML attributes</a>
```

This space should *only* be added if there are attributes so we do this within a simple `if` statement.

```python
def html_element(content, tag, **attributes):
    attrs = [f'{k}="{v}"' for k, v in attributes.items()]
    attrs = " ".join(attrs)
    if attrs:
        attrs = f" {attrs}"
    return f"<{tag}{attrs}>{content}</{tag}>"
```

> This function is combining a number of common techniques.
Make sure you understand each step.


The code now works well, we can generate what we want.

```python
a = html_element(
    "HTML attributes", "a", 
    href="#html-attributes"
)
h2 = html_element(
    "HTML attributes", "h2", 
    id="html-attributes"
)
```

It produces exactly the output we wanted.

```plaintext
<a href="#html-attributes">HTML attributes</a>
<h2 id="html-attributes">HTML attributes</h2>
```

### One final update

Notice our function has a problem, we cannot add a `class="my-class"` attribute because `class` is a python keyword.
This is unavoidable and no solution to this problem is ideal.

We can allow the calling code to pass `_class="my-class"` and convert it inside the function.

```python
def html_element(content, tag, _class=None, **attributes):
    if _class:
        attributes['class'] = _class
    attrs = [f'{k}="{v}"' for k, v in attributes.items()]
    attrs = " ".join(attrs)
    if attrs:
        attrs = f" {attrs}"
    return f"<{tag}{attrs}>{content}</{tag}>"

html_element("hello", "p", _class="my-class")
```

Or, more generally, we can strip all underscores from the beginning of attribute names.

```python
def html_element(content, tag, **attributes):
    attrs = [f'{k.lstrip("_")}="{v}"' for k, v in attributes.items()]
    attrs = " ".join(attrs)
    if attrs:
        attrs = f" {attrs}"
    return f"<{tag}{attrs}>{content}</{tag}>"

html_element("hello", "p", _class="my-class", _def="not a real HTML attribute")
```

In this way, keyword clashes can be handled in a general way.

{{ challenges[1] }}

