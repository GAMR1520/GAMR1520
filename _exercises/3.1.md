---
week: 3
lab: 1
lang: python
title: Object-oriented python
description: This exercise introduces object-oriented programming in python. We will develop very simple classes and explore the complexities and benefits of this approach. 
---

{% assign challenges = site.challenges | where:"lab", 3.1 | sort: "id" %}

In this set of exercises we will introduce the `class` keyword and explore *dunder* methods such as `__init__()` and the *instance* argument which is implicitly passed to class methods.

Classes in python are definitions of new data types from which we can create instances.
Just like `str` or `list` are types and `'hello'` and `[1, 2, 3]` are instances.

In practice, they are a way of organising code as *namespaces*. 
They are collections of properties, including both data and functions (known as *methods*).

Our starting point will look like this:

```python
class MyClass:
    pass
```

> For an empty class the `pass` keyword is necessary to avoid an IndentationError in the compound statement.
It literally does nothing but represent an empty code block.

We can see the code above defines a `class` compound statement containing only the (capitalised) name of our `MyClass` class.
This is how classes are defined.
Anything we put inside the code block will be part of the class definition and will be available to all instances of the class.

We can now refer directly to the `MyClass` class, for example, we can print it.

```python
print(MyClass)
```
{: .small-margin}
```plaintext
<class '__main__.MyClass'>
```
{: .small-margin}

The output shows the default representation for a `MyClass` instance indicating that the class is defined in the `__main__` module.

> In python the file you execute is known as the `__main__` module.
> Double underscores indicate that `__main__` is part of the python infrastructure.

We create an *instance* of our `MyClass` class like this.

```python
my_instance = MyClass()
```

> The parentheses indicate we are *calling* our class.
In fact, we are calling the class *constructor* method which can be used to customise our instances.
This is **really important** and we will talk about it a lot later.
For now, we will concentrate on the class itself.

If we print the instance, we can see it is a `MyClass` object.
We can also pass our instance to the `id()` function (and print the result formatted as hexadecimal) and the `type()` function, just like with any value.

```python
print(my_instance)
print(f'{id(my_instance):#x}')
print(type(my_instance))
```
{: .small-margin}
```plaintext
<__main__.MyClass object at 0x7f4f03e60280>
0x7f4f03e60280
<class '__main__.MyClass'>
```
{: .small-margin}

We can see that our `my_instance` variable points to an object which has the type `MyClass`.

> This is the default representation, we shall see later that we can customise how our types are represented.


## Attributes

Our `MyClass` instance `my_instance` is a bit pointless.
We need to define something meaningful and add attributes.

For example, we can create a `class` to represent a coordinate, i.e. a 2-dimensional (x, y) location on a plane.
Our class should define two numerical values, `x` and `y` so each instance can be a unique point.

It's very important to be clear on the difference between a *class* and an *instance*.
Classes can be given attributes like this:

```python
class Coordinate:
    x = 0
    y = 0
```

And we can create any number of instances and access the class-level attributes using dot notation.

```python
c1 = Coordinate()
c2 = Coordinate()
print(f"{c1.x=}, {c1.y=}")
print(f"{c2.x=}, {c2.y=}")
```
{: .small-margin}

```plaintext
c1.x=0, c1.y=0
c2.x=0, c2.y=0
```
{: .small-margin}

The problem here is that every instance of our coordinate class has the same values for `x` and `y`.
Defining attributes on the class like this provides us with default values or constants that individual instances can optionally override.

We can set instance attributes using dot notation.

```python
c1 = Coordinate()
c2 = Coordinate()
c1.x = 2
c2.y = -3
print(f"{c1.x=}, {c1.y=}")
print(f"{c2.x=}, {c2.y=}")
```
{: .small-margin}
```plaintext
c1.x=2, c1.y=0
c2.x=0, c2.y=-3
```
{: .small-margin}

Notice that the default values are unchanged.

We can also modify and add attributes on the `Coordinate` class itself.

> When we try to access an attribute on an instance, if the attribute is not found, then the class will be checked.

```python
c1 = Coordinate()
c2 = Coordinate()
c1.x = 2
c2.y = -3
Coordinate.z = 5
print(f"{c1.x=}, {c1.y=}, {c1.z=}")
print(f"{c2.x=}, {c2.y=}, {c2.z=}")
```
{: .small-margin}
```plaintext
c1.x=2, c1.y=0, c1.z=5
c2.x=0, c2.y=-3, c2.z=5
```
{: .small-margin}

If we do the same on only one instance and nothing is found on the class, then an error is raised for instances without the new attribute.

```python
c1 = Coordinate()
c2 = Coordinate()
c1.x = 2
c2.y = -3
c1.z = 5
print(f"{c1.x=}, {c1.y=}, {c1.z=}")
print(f"{c2.x=}, {c2.y=}, {c2.z=}")
```
{: .small-margin}

```plaintext
c1.x=2, c1.y=0, c1.z=5
Traceback (most recent call last):
  File "path/to/coordinates.py", line 11, in <module>
    print(f"{c2.x=}, {c2.y=}, {c2.z=}")
AttributeError: 'Coordinate' object has no attribute 'z'
```
{: .small-margin}

> The `c1` instance prints correctly, but when we try to access `c2.z` an `AttributeError` is raised because this object doesn't have the requested attribute.

### Methods

A special kind of attribute is a function.
As we have seen, functions in python have a type and are just like any other data (though they are executable).

> See [defining custom functions]({{"references/functions#defining-custom-functions" | relative_url}}) for a reminder

```python
def my_func():
    pass

print(type(my_func))
```
{: .small-margin}
```plaintext
<class 'function'>
```
{: .small-margin}

Functions defined inside class definitions are known as *methods*.
There is one main difference from *normal* functions when we define custom methods on a class.

**When called from an instance, a method will receive a copy of the instance as the first argument.**

This is best explained with some examples.

First, let's add a method to our class that does nothing.
What happens when we call it?

```python
class Coordinate:
    x = 0
    y = 0

    def my_method():
        pass

c1 = Coordinate()
c1.my_method()
```
{: .small-margin}
```plaintext
TypeError: Coordinate.my_method() takes 0 positional arguments but 1 was given
```
{: .small-margin}

The error is telling us that the method was passed one argument, even though we passed nothing.
This extra argument is a reference to the instance `c1`.

Let's update our code to have a look at the argument.
We'll make two instances to see the impact.

```python
class Coordinate:
    x = 0
    y = 0

    def my_method(arg):
        print(arg)

c1 = Coordinate()
c2 = Coordinate()

c1.my_method()
c2.my_method()
```
{: .small-margin}
```plaintext
<__main__.Coordinate object at 0x7fc3e3cd0310>
<__main__.Coordinate object at 0x7fc3e3cd02e0>
```
{: .small-margin}

The code no longer raises an error because we are handling the single argument that was passed.
The output is showing us that we are printing the two `Coordinate` instances.
We can see that the two instances are *different* (because they have different locations in memory).

This is the core mechanism of classes and instances in python, *all methods on a class* automatically receive a copy of the instance as an additional first argument when called from an instance using dot notation (e.g. `c1.my_method()`).

By convention, python programmers *always* name this argument `self` to avoid confusion.

> The above code is for demonstration purposes only.
*Never* use a different variable name for this, *always* use `self`. 

All subsequent arguments are treated as with normal functions.

```python
class Coordinate:
    x = 0
    y = 0

    def my_method(self, *args, **kwargs):
        print(args, kwargs)


c1 = Coordinate()
c2 = Coordinate()

c1.my_method(1, 2, 3)
c2.my_method(hello='world')
```
{: .small-margin}
```plaintext
(1, 2, 3) {}
() {'hello': 'world'}
```
{: .small-margin}



## Class constructors

When we create an instance of a class, we are implicitly calling a *constructor* method called `__init__`.
All classes define an `__init__` method which effectively does nothing by default.

Defining an `__init__` method of our own is a convenient way to create customised instances.
In fact, with a constructor, we don't really need the `x` and `y` attributes to be defined on the class any more.

```python
class Coordinate:
    def __init__(self, x, y):
        self.x = x
        self.y = y
```

Inside the class definition we have a single function (method) with the special *dunder* (double-underscore) name `__init__`.
Python automatically recognises functions with this name as the *constructor* for the class.
Our constructor takes the automatic `self` argument plus two more arguments, `x`, and `y`.

When we create *instances* of our `Coordinate` class, we are implicitly calling the `__init__` constructor method, and we only pass in the two arguments because we know `self` is automatically passed.

```python
origin = Coordinate(0, 0)
c1 = Coordinate(3, 8)
c2 = Coordinate(-4, 2)
```

Here we are passing the two values (e.g. `0` and `0` in the first example) to the `__init__` method, they correspond to the `x` and `y` arguments.
Inside the body of the method, we are setting attributes `self.x` and `self.y` using the values of the `x` and `y` arguments passed into the *constructor* (`0` and `0` in the first example).

> This is similar to constructors for built-in types like `int()`, `bool()`, `list()` etc.
We can initialise our instances automatically as part of the class machinery.

Now we can see our instances have been initialised with the `x` and `y` values.

```python
print(f'({origin.x}, {origin.y})')
print(f'({c1.x}, {c1.y})')
print(f'({c2.x}, {c2.y})')
```
{: .small-margin}
```plaintext
(0, 0)
(3, 8)
(-4, 2)
```
{: .small-margin}


## Changing how instances are displayed

Remember when we called `print()` on `Coordinate` instances, we got stuff like this. 

```python
class Coordinate:
    def __init__(self, x, y):
        self.x = x
        self.y = y

origin = Coordinate(0, 0)
c1 = Coordinate(1, 2)
c2 = Coordinate(3, 4)

print(origin)
print(c1)
print(c2)
```
{: .small-margin}
```plaintext
<__main__.Coordinate object at 0x7fec1d6d4280>
<__main__.Coordinate object at 0x7fec1d6d4070>
<__main__.Coordinate object at 0x7fec1d6d7c10>
```
{: .small-margin}

When we pass an object into the `print()` function, it will be converted into a string before it is output to the terminal. 

> The terminal can *only* display strings.
> This is also why `input` always returns a string.

The `print()` function will actually pass everything it gets into the `str()` constructor to create a string instance which is initialised with our object.

We can pass any object into the `str()` constructor to generate a string representation of that object.

```python
print([str(i) for i in (1.1, True, Coordinate(0, 0))])
```
{: .small-margin}
```plaintext
['1.1', 'True', '<__main__.Coordinate object at 0x7fabd3cafc10>']
```
{: .small-margin}


> Wait... how does the `str()` constructor know how to convert my custom object into a string?

The `str()` constructor will accept an object of any type and will attempt to call the `__str__` method of the object which will return a string representation of the object.

> Think about this...

Anything can be converted to a string and anything can be passed into the `print()` method because all classes have a default `__str__` method.

We can demonstrate this by simply calling the `__str__` method on some objects, they all have one.

```python
print([i.__str__() for i in (1.1, True, Coordinate(0, 0))])
```
{: .small-margin}
```plaintext
['1.1', 'True', '<__main__.Coordinate object at 0x7fabd3cafc10>']
```
{: .small-margin}

This is really nice.
Objects are responsible for telling the `str()` constructor what a string representation should be.
The default `__str__` implementation is pretty unhelpful.
We can give our class a customised `__str__` method which returns a customised string representation of the `Coordinate` to show the key instance attributes.

```python
class Coordinate:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __str__(self):
        return f'Coordinate({self.x}, {self.y})'

origin = Coordinate(0, 0)
c1 = Coordinate(1, 2)
c2 = Coordinate(3, 4)

print(origin)
print(c1)
print(c2)
```
{: .small-margin}
```plaintext
Coordinate(0, 0)
Coordinate(1, 2)
Coordinate(3, 4)
```
{: .small-margin}

> We have followed the convention of representing the instance as the code that would create it.
This works nicely for simple classes, though sometimes it can be useful to use a different approach.

## Operators

The exact same idea is used to implement operators.
For example, we can implement a method `__sub__` which takes the normal `self` argument, plus another argument `other` which will be the other operand.

So these two lines are equivalent.

```python
a - b
a.__sub__(b)
```

So let's implement a `__sub__` method on our `Coordinate` class.

```python
class Coordinate:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __sub__(self, other):
        return Coordinate(self.x - other.x, self.y - other.y)

    def __str__(self):
        return f'Coordinate({self.x}, {self.y})'

c1 = Coordinate(1, 2)
c2 = Coordinate(3, 4)

print(c1 - c2)
```
{: .small-margin}
```plaintext
Coordinate(-2, -2)
```
{: .small-margin}

### Mutable attributes

There is a potential confusion with attributes defined on a class.
So far we have seen examples of immutable values (the integers, `x` and `y`). 
In these cases, when we *assign* to an instance variable, we are 

Adding mutable objects as attributes of a class can give confusing results because a mutation triggered by one instance will influence all instances.


>### Advanced and rarely needed
>
>It is possible to define a method without adding the `self` argument.
>But this must be called from the class itself, not an instance.
>
>```python
>Coordinate.my_method(1, 2, 3)
>Coordinate.my_method(hello='world')
>```
>
> If we do want to access a method like this from an instance, we can declare it with the [staticmethod](https://docs.python.org/3/library/functions.html#staticmethod) decorator.
>```python
>class Coordinate:
>    x = 0
>    y = 0
>
>    def my_method(self, *args, **kwargs):
>        print(self, args, kwargs)
>
>    @staticmethod
>    def my_static_method(*args, **kwargs):
>        print(args, kwargs)
>
>c1 = Coordinate()
>c1.my_method(1, 2, 3)
>c1.my_static_method(1, 2, 3)
>```
> Though, without access to either the instance data held on the `self` argument or the class attributes, static methods don't add much benefit over simple functions defined outside of the class.
>
>The `@classmethod` decorator will ensure a function is provided a reference to the class rather than the instance. 
>Unless you have a compelling reason to use one, probably don't bother.
We won't be covering decorator syntax in this module.

