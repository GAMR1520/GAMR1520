---
week: 3
lab: 1
lang: python
title: Object-oriented python
description: This exercise introduces object-oriented programming in python. We will develop very simple classes and explore the complexities and benefits of this approach. 
---

{% assign challenges = site.challenges | where:"lab", 3.1 | sort: "id" %}

In this set of exercises we will introduce the `class` keyword and explore *dunder* methods such as `__init__()` and the *instance* argument which is implicitly passed to class methods.

Classes in python are definitions of new data types from which we can create instances.
Just like `str` or `list` are types and `'hello'` and `[1, 2, 3]` are instances.

<figure>
    <div class="mermaid">
    flowchart LR;
        subgraph instances [Instances]
            1
            hello["'hello'"]
            listA["[1, 2, 3]"]
            listB["['a', 'b', 'c']"]
            2
            world["'world'"]
        end
        subgraph types ["Types (or classes)"]
            int
            str
            list
        end
        1 --> int
        hello --> str
        2 --> int
        world --> str
        listA --> list
        listB --> list
    </div>
</figure>

In practice, classes are a way of organising code as *namespaces*.
They are collections of properties, including both data and functions (functions defined within classes are known as *methods*).

Our starting point will look like this:

```python
class MyClass:
    pass
```

> For an empty class the `pass` keyword is necessary to avoid an IndentationError in the compound statement.
It literally does nothing but represent an empty code block.

We can see the code above defines a `class` compound statement containing only the (capitalised) name of our `MyClass` class.
This is how classes are defined.
Anything we put inside the code block will be part of the class definition and will be available to all instances of the class.

We can now refer directly to the `MyClass` class, for example, we can print it.

```python
class MyClass:
    pass

print(MyClass)
```
{: .small-margin}
```plaintext
<class '__main__.MyClass'>
```
{: .small-margin}

The output shows the default representation for a `MyClass` instance indicating that the class is defined in the `__main__` module.

> In python *the file you execute* is known as the `__main__` module.
> Double underscores indicate that `__main__` is part of the python infrastructure.

We create an *instance* of our `MyClass` class like this.

```python
class MyClass:
    pass

my_instance = MyClass()
```

> The parentheses indicate we are *calling* our class.
In fact, we are calling the class *constructor* method which can be used to customise our instances.
This is **really important** and we will talk about it a lot later.
For now, we will concentrate on the class itself.

If we print the instance, we can see it is a `MyClass` object.
We can also pass our instance to the `id()` function (and print the result formatted as hexadecimal) and the `type()` function, just like with any value.

```python
class MyClass:
    pass

my_instance = MyClass()

print(my_instance)
print(f'{id(my_instance):#x}')
print(type(my_instance))
```
{: .small-margin}
```plaintext
<__main__.MyClass object at 0x7f4f03e60280>
0x7f4f03e60280
<class '__main__.MyClass'>
```
{: .small-margin}

We can see that our `my_instance` variable points to an object which has the type `MyClass`.

> This is the default representation, we shall see later that we can customise how our types are represented.


## Attributes

Our `MyClass` instance `my_instance` is a bit pointless.
We need to define something meaningful and add attributes.

For example, we can create a `class` to represent a coordinate, i.e. a 2-dimensional (x, y) location on a plane.
Our class should define two numerical values, `x` and `y` so each instance can be a unique point.

It's very important to be clear on the difference between a *class* and an *instance*.
Classes can be given attributes like this:

```python
class Coordinate:
    x = 0
    y = 0
```

And we can create any number of instances and access the class-level attributes using dot notation.

```python
class Coordinate:
    x = 0
    y = 0

c1 = Coordinate()
c2 = Coordinate()
print(f"{c1.x=}, {c1.y=}")
print(f"{c2.x=}, {c2.y=}")
```
{: .small-margin}

```plaintext
c1.x=0, c1.y=0
c2.x=0, c2.y=0
```
{: .small-margin}

The problem here is that every instance of our coordinate class has the same values for `x` and `y`.
Defining attributes on the class like this provides us with default values or constants that individual instances can optionally override.

We can set instance attributes using dot notation.

```python
class Coordinate:
    x = 0
    y = 0

c1 = Coordinate()
c2 = Coordinate()
c1.x = 2
c2.y = -3
print(f"{c1.x=}, {c1.y=}")
print(f"{c2.x=}, {c2.y=}")
```
{: .small-margin}
```plaintext
c1.x=2, c1.y=0
c2.x=0, c2.y=-3
```
{: .small-margin}

Notice that the default values are unchanged.

> When we try to access an attribute on an instance, if the attribute is not found, then the class will be checked.

We can also modify and add attributes on the `Coordinate` class itself.

```python
class Coordinate:
    x = 0
    y = 0

c1 = Coordinate()
c2 = Coordinate()
c1.x = 2
c2.y = -3
Coordinate.z = 5
print(f"{c1.x=}, {c1.y=}, {c1.z=}")
print(f"{c2.x=}, {c2.y=}, {c2.z=}")
```
{: .small-margin}
```plaintext
c1.x=2, c1.y=0, c1.z=5
c2.x=0, c2.y=-3, c2.z=5
```
{: .small-margin}


> Basically, dot notation gives us read/write access to the attributes.
In python there is no public/private/protected attributes.
If you want users of your class to leave something alone, the convention is to name it with a leading underscore like `_x`.
You should treat anything named this way as an implementation detail that may change in the future.


If we do the same on only one instance and nothing is found on the class, then an error is raised for instances without the new attribute.

```python
class Coordinate:
    x = 0
    y = 0

c1 = Coordinate()
c2 = Coordinate()
c1.x = 2
c2.y = -3
c1.z = 5
print(f"{c1.x=}, {c1.y=}, {c1.z=}")
print(f"{c2.x=}, {c2.y=}, {c2.z=}")
```
{: .small-margin}

```plaintext
c1.x=2, c1.y=0, c1.z=5
Traceback (most recent call last):
  File "path/to/coordinates.py", line 11, in <module>
    print(f"{c2.x=}, {c2.y=}, {c2.z=}")
AttributeError: 'Coordinate' object has no attribute 'z'
```
{: .small-margin}

> The `c1` instance prints correctly, but when we try to access `c2.z` an `AttributeError` is raised because this object doesn't have the requested attribute.

### Methods

A function defined within a class is known as a method.
As we have seen, functions in python have a type and are just like any other data (though they are executable).

> See [defining custom functions]({{"references/functions#defining-custom-functions" | relative_url}}) for a reminder

```python
def my_function():
    pass

print(my_function)
```
{: .small-margin}
```plaintext
<function my_function at 0x7f8e5a766680>
```
{: .small-margin}

Functions defined inside class definitions are known as *methods*.
We can define a method within our `Coordinate` class.

```python
class Coordinate:
    x = 0
    y = 0

    def my_method():
        pass

print(Coordinate.my_method)
```
```plaintext
<function Coordinate.my_method at 0x7f8e5a7660e0>
```

There is one main difference from *normal* functions when we define custom methods on a class.

**When called from an instance, a method will receive a copy of the instance as the first argument.**

This is best explained with some examples.

What happens when we call our method?

```python
class Coordinate:
    x = 0
    y = 0

    def my_method():
        pass

c1 = Coordinate()
c1.my_method()
```
{: .small-margin}
```plaintext
TypeError: Coordinate.my_method() takes 0 positional arguments but 1 was given
```
{: .small-margin}

> This is unexpected, so this must be important.

The error is telling us that the method was passed one argument, even though we passed nothing.
This extra argument is a reference to the instance `c1`.
It is automatically added when we call our method *from an instance* using dot notation.

Let's update our code to have a look at the argument.
We'll make two instances to see the impact.

> Notice the `my_method` function now takes one argument (`arg`) and prints it. 

```python
class Coordinate:
    x = 0
    y = 0

    def my_method(arg):
        print(arg)

c1 = Coordinate()
c2 = Coordinate()

c1.my_method()
c2.my_method()
```
{: .small-margin}
```plaintext
<__main__.Coordinate object at 0x7fc3e3cd0310>
<__main__.Coordinate object at 0x7fc3e3cd02e0>
```
{: .small-margin}

The code no longer raises an error because we are handling the single argument that was passed.
The output is showing us that we are printing the two `Coordinate` instances.
We can see that the two instances are *different* (because they have different locations in memory).

This is the core mechanism of classes and instances in python, *all methods on a class* automatically receive a copy of the instance as an additional first argument when called from an instance using dot notation (e.g. `c1.my_method()`).

By convention, python programmers *always* name this argument `self` to avoid confusion.

> The above code is for demonstration purposes only.
*Never* use a different variable name for this.
*Always use `self`*. 

All subsequent arguments are treated as with normal functions.

```python
class Coordinate:
    x = 0
    y = 0

    def my_method(self, *args, **kwargs):
        print(args, kwargs)


c1 = Coordinate()
c2 = Coordinate()

c1.my_method(1, 2, 3)
c2.my_method(hello='world')
```
{: .small-margin}
```plaintext
(1, 2, 3) {}
() {'hello': 'world'}
```
{: .small-margin}

The advantage of this is that methods all have access to the instance and all attributes.
This allows for methods that wil modify our instance data.

```python
class Coordinate:
    x = 0
    y = 0

    def invert(self):
        self.x, self.y = self.y, self.x


c1 = Coordinate()
c1.x = 10
c1.y = 5

print(c1.x, c1.y)
c1.invert()
print(c1.x, c1.y)
```
{: .small-margin}
```plaintext
10 5
5 10
```
{: .small-margin}


## Class constructors

Notice that above we are setting the instance attributes manually after we create the instance.
This is very awkward and annoying. 
To avoid this, we can define a custom *constructor* method.

When we create an instance of a class, we are implicitly calling a *constructor* method called `__init__`.
All classes define an `__init__` method which effectively does nothing by default.

Defining an `__init__` method of our own is a convenient way to create customised instances.
In fact, with a constructor, we don't really need the `x` and `y` attributes to be defined on the class any more.

The above example can be rewritten as follows:

```python
class Coordinate:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def invert(self):
        self.x, self.y = self.y, self.x

c1 = Coordinate(10, 5)

print(c1.x, c1.y)
c1.invert()
print(c1.x, c1.y)
```
{: .small-margin}
```plaintext
10 5
5 10
```
{: .small-margin}

Inside the class definition we have added a new function (method) with the special *dunder* (double-underscore) name `__init__`.
Python automatically recognises functions with this name as the *constructor* for the class.
Our constructor takes the automatic `self` argument plus two more arguments, `x`, and `y`.

When we create multiple *instances* of our `Coordinate` class, we are implicitly calling the `__init__` constructor method, and we pass in two arguments because we know `self` is automatically passed.

```python
class Coordinate:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def invert(self):
        self.x, self.y = self.y, self.x

origin = Coordinate(0, 0)
c1 = Coordinate(3, 8)
c2 = Coordinate(-4, 2)
```

Here we are passing the two values (e.g. `0` and `0` in the first example) to the `__init__` method, they correspond to the `x` and `y` arguments.
Inside the body of the method, we are setting attributes `self.x` and `self.y` using the values of the `x` and `y` arguments passed into the *constructor* (`0` and `0` in the first example).

> This is similar to constructors for built-in types like `int()`, `bool()`, `list()` etc.
We can initialise our instances automatically as part of the class machinery.

Now we can see our instances have been initialised with the `x` and `y` values.

```python
class Coordinate:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def invert(self):
        self.x, self.y = self.y, self.x
        
origin = Coordinate(0, 0)
c1 = Coordinate(3, 8)
c2 = Coordinate(-4, 2)

print(f'({origin.x}, {origin.y})')
print(f'({c1.x}, {c1.y})')
print(f'({c2.x}, {c2.y})')
```
{: .small-margin}
```plaintext
(0, 0)
(3, 8)
(-4, 2)
```
{: .small-margin}


## Changing how instances are displayed

Remember when we called `print()` on `Coordinate` instances, we got output like this. 

```python
class Coordinate:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def invert(self):
        self.x, self.y = self.y, self.x

origin = Coordinate(0, 0)
c1 = Coordinate(1, 2)
c2 = Coordinate(3, 4)

print(origin)
print(c1)
print(c2)
```
{: .small-margin}
```plaintext
<__main__.Coordinate object at 0x7fec1d6d4280>
<__main__.Coordinate object at 0x7fec1d6d4070>
<__main__.Coordinate object at 0x7fec1d6d7c10>
```
{: .small-margin}

This is because, when we pass an object into the `print()` function, it is converted into a string before it is output to the terminal. 

> The terminal can *only* display strings.
> This is also why `input` always returns a string.

The `print()` function passes the object into the `str()` constructor to create a string instance which is initialised with our object.
We can pass any object into the `str()` constructor to generate a string representation of that object.

```python
print([str(i) for i in (1.1, True, Coordinate(0, 0))])
```
{: .small-margin}
```plaintext
['1.1', 'True', '<__main__.Coordinate object at 0x7fabd3cafc10>']
```
{: .small-margin}


We can see that the `print()` function produces a similar string.
This is because it is calling the `str()` function internally.

```python
class Coordinate:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def invert(self):
        self.x, self.y = self.y, self.x

for x in range(3):
    for y in range(3):
        print(Coordinate(x, y))
```
{: .small-margin}
```plaintext
<__main__.Coordinate object at 0x7f960db042e0>
<__main__.Coordinate object at 0x7f960db042e0>
<__main__.Coordinate object at 0x7f960db042e0>
<__main__.Coordinate object at 0x7f960db04040>
<__main__.Coordinate object at 0x7f960db04040>
<__main__.Coordinate object at 0x7f960db04040>
<__main__.Coordinate object at 0x7f960db042e0>
<__main__.Coordinate object at 0x7f960db042e0>
<__main__.Coordinate object at 0x7f960db042e0>
```
{: .small-margin}

> Wait... how does the `str()` constructor know how to convert my custom object into a string?

The `str()` constructor will attempt to call the `__str__` method of any object which is passed to it.
The `__str__` method must return a string representation of the object.

> Think about this...

Anything can be converted to a string and anything can be passed into the `print()` method because all classes have a default `__str__` method.

We can demonstrate this by simply calling the `__str__` method on some objects, they all have one.

```python
print([i.__str__() for i in (1.1, True, Coordinate(0, 0))])
```
{: .small-margin}
```plaintext
['1.1', 'True', '<__main__.Coordinate object at 0x7fabd3cafc10>']
```
{: .small-margin}

This is really nice.
Objects are responsible for telling the `str()` constructor what a string representation should be.

The default `__str__` implementation is pretty unhelpful.
We can give our class a customised `__str__` method which returns a customised string representation of the `Coordinate` to show the key instance attributes.

```python
class Coordinate:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def invert(self):
        self.x, self.y = self.y, self.x

    def __str__(self):
        return f'({self.x}, {self.y})'

origin = Coordinate(0, 0)
c1 = Coordinate(1, 2)
c2 = Coordinate(3, 4)

print(origin)
print(c1)
print(c2)
```
{: .small-margin}
```plaintext
(0, 0)
(1, 2)
(3, 4)
```
{: .small-margin}

Now anywhere we print a `Coordinate` instance, it will be appear as a pair of numbers in brackets.

### The `__repr__` method

There is a related method `__repr__` which is very similar to `__str__` but is intended to produce a more explicit string representation of an object that indicates the type as well as the values of instance attributes.
Just as the built-in `str()` function calls `__str__`, there is a similar built-in `repr()` function which will call `__repr__` and return the resulting string.

> You can think of `__str__` as returning a *user-friendly* representation whilst `__repr__` returns a *developer-friendly* representation. 

If we implement this then we can add some more context to the string.

```python
class Coordinate:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def invert(self):
        self.x, self.y = self.y, self.x

    def __str__(self):
        return f'({self.x}, {self.y})'

    def __repr__(self):
        return f"Coordinate(x={self.x}, y={self.y})"

origin = Coordinate(0, 0)
c1 = Coordinate(1, 2)
c2 = Coordinate(3, 4)

print(repr(origin))
print(repr(c1))
print(repr(c2))
```
{: .small-margin}
```plaintext
Coordinate(x=0, y=0)
Coordinate(x=1, y=2)
Coordinate(x=3, y=4)
```
{: .small-margin}

The output shows a more explicit representation of our object (which could otherwise be confused with a tuple).

> We have followed the convention of *representing* the instance as the code that would create it.
> This works nicely for simple classes, though sometimes it can be useful to use a different approach.

This can also be generated within an f-string using the `!r` formatting.

```python
print(f"{origin!r}")
print(f"{c1!r}")
print(f"{c2!r}")
```

## Operators

The exact same idea is used to implement operators.
For example, we can implement a method `__sub__` which takes the normal `self` argument, plus another argument `other` which will be the other operand.

So these two lines are exactly equivalent.

```python
a - b
a.__sub__(b)
```

Obviously, the first one is a neater way of doing it and is always preferred.
The key point here is that our `Coordinate` object can define how it interacts with operators.


So let's implement a `__sub__` method on our `Coordinate` class.

```python
class Coordinate:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def invert(self):
        self.x, self.y = self.y, self.x

    def __sub__(self, other):
        return Coordinate(self.x - other.x, self.y - other.y)

    def __str__(self):
        return f'Coordinate({self.x}, {self.y})'

    def __repr__(self):
        return f"Coordinate(x={self.x}, y={self.y})"

c1 = Coordinate(1, 2)
c2 = Coordinate(3, 4)

print(f"{c1} - {c2} = {c1 - c2}")
```
{: .small-margin}
```plaintext
(1, 2) - (3, 4) = (-2, -2)
```
{: .small-margin}

Of course, we can implement addition, multiplication, division etc. in the same way using `__mul__`, `__add__`, `__truediv__` and [many other special methods](https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types) which each correspond to a specific operator.



{{ challenges[0] }}


## Mutable attributes and class methods

It is possible to define a method to a class without adding the `self` argument.
But this must be called from the class itself, not from an instance.

```python
from random import randint

class Coordinate:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def random(min_x=-10, max_x=10, min_y=-10, max_y=10):
        return Coordinate(
            randint(min_x, max_x), 
            randint(min_y, max_y)
        )

    def __repr__(self):
        return f"Coordinate(x={self.x}, y={self.y})"

a = Coordinate.random()
b = Coordinate.random()
print(a, b)
```

This is absolutely fine and can be a useful way to add additional constructors like the example.

If we want to access a method like this from an instance, we can declare it with the [staticmethod](https://docs.python.org/3/library/functions.html#staticmethod) decorator.
```python
from random import randint

class Coordinate:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    @staticmethod
    def random(min_x=-10, max_x=10, min_y=-10, max_y=10):
        return Coordinate(
            randint(min_x, max_x), 
            randint(min_y, max_y)
        )

    def __repr__(self):
        return f"Coordinate(x={self.x}, y={self.y})"

a = Coordinate.random()
print(a)
b = a.random()
```

Though, without access to either the instance data held on the `self` argument or the class attributes, static methods don't add much benefit over simple functions defined outside of the class.

The `@classmethod` decorator will ensure a function is provided a reference to the class rather than the instance. 
This allows for inheritance hierarchies to be implemented with some convenience. 
However, unless you have a compelling reason to use one, probably don't bother.
We won't be covering decorator syntax in this module, nor will we be covering inheritance.
Mainly because composition should *always* be favoured over inheritance.

```
from random import randint

class Coordinate:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    @staticmethod
    def random(cls, min_x=-10, max_x=10, min_y=-10, max_y=10):
        return cls(
            randint(min_x, max_x), 
            randint(min_y, max_y)
        )

    def __repr__(self):
        return f"Coordinate(x={self.x}, y={self.y})"

a = Coordinate.random()
print(a)
```

{{ challenges[1] }}
